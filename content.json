[{"title":"git","date":"2019-06-22T07:28:01.000Z","path":"2019/06/22/git/","text":""},{"title":"修改Docker的默认镜像存储位置","date":"2019-06-21T17:50:32.000Z","path":"2019/06/22/修改Docker的默认镜像存储位置/","text":"修改Docker的默认镜像存储位置默认情况下Docker的存放位置为：/var/lib/docker可以通过下面命令查看具体位置： 1sudo docker info | grep \"Docker Root Dir\" 数据盘挂在 /data 方案1：使用软链接方式（不建议，可以了解一下）1.首先停掉Docker服务： 1systemctl restart docker 或者 1service docker stop 2.对之前的数据做个文件备份 1tar -zcC /var/lib/docker &gt;/mnt/var_lib_docker-backup-$(date + %s).tar.gz 3.然后迁移整个/var/lib/docker目录到目的路径： 1mv /var/lib/docker /data/docker 4.建立symlink软链接 1ln -s /data/docke /var/lib/docker 5.确认文件夹类型为symlink 类型 1ls -al /var/lib/docker 6.这时候启动Docker时发现存储目录依旧是/var/lib/docker，但是实际上是存储在数据盘的，你可以在数据盘上看到容量变化。 1sudo systemctl start docker 方案2：修改镜像和容器的默认存放路径1.Docker的配置文件可以设置大部分的后台进程参数，在各个操作系统中的存放位置不一致，在 Ubuntu 中的位置是：/etc/default/docker，在 CentOS中的位置是：/etc/sysconfig/docker。如果是 CentOS6 则添加下面这行： 1OPTIONS=--graph=\"/data/docker\"--selinux-enabled -H fd:// 如果是 Ubuntu 则添加下面这行（因为 Ubuntu 默认没开启 selinux）： 1OPTIONS=--graph=\"/data/docker\" -H fd:// 或者 1DOCKER_OPTS=\"-g /data/docker\" 最后重新启动，Docker 的路径就改成 /data/docker 了。 如果是CentOS7 就是用如下：修改docker.service文件，使用–graph参数指定存储位置 1sudo vim /usr/lib/systemd/system/docker.service 文本内容：ExecStart=/usr/bin/dockerd下面添加如下内容： 1ExecStart=/usr/bin/dockerd --graph /data/tools/docker 2.修改完成后reload配置文件 1sudo systemctl daemon-reload 3.重启docker服务 1sudo systemctl restart docker.service 备注：如果docker是1.12或以上的版本，可以修改（或新建）daemon.json文件。修改后会立即生效，不需重启docker服务。 1sudo vim /etc/docker/daemon.json 修改如下： 1&#123;\"registry-mirrors\": [\"http://***.***.com\"],\"graph\":\"/data/tools/docker\"&#125;"},{"title":"分布式任务调度系统对比","date":"2019-06-21T17:50:32.000Z","path":"2019/06/22/分布式任务调度系统对比/","text":"#分布式任务调度系统对比 项目背景及社区力量X-Job ： 大众点评公司下员工许雪里、贡献者 3人; github有2470star、1015fork | QQ讨论群6个 | 有登记在使用的超过40家公司 | 文档齐全 E-Job ： 当当网开源，贡献者17人; github有2524star、1015fork | QQ讨论群１个、源码讨论群１个 | 有登记在使用的超过50家公司 | 文档齐全 ｜ 有明确的发展计划 支持集群部署X-Job ： 集群部署唯一要求为：保证每个集群节点配置（db和登陆账号等）保持一致。调度中心通过db配置区分不同集群。 执行器支持集群部署，提升调度系统可用性，同时提升任务处理能力。集群部署唯一要求为：保证集群中每个执行器的配置项 “xxl.job.admin.addresses/调度中心地址” 保持一致，执行器根据该配置进行执行器自动注册等操作。 E-Job ： 重写Quartz基于数据库的分布式功能，改用Zookeeper实现注册中心 作业注册中心： 基于Zookeeper和其客户端Curator实现的全局作业注册控制中心。用于注册，控制和协调分布式作业执行。 多节点部署时任务不能重复执行X-Job ： 使用Quartz基于数据库的分布式功能 E-Job ： 将任务拆分为n个任务项后，各个服务器分别执行各自分配到的任务项。一旦有新的服务器加入集群，或现有服务器下线，elastic-job将在保留本次任务执行不变的情况下，下次任务开始前触发任务重分片。 日志可追溯X-Job ： 支持，有日志查询界面 E-Job ： 可通过事件订阅的方式处理调度过程的重要事件，用于查询、统计和监控。Elastic-Job目前提供了基于关系型数据库两种事件订阅方式记录事件。 监控告警X-Job ： 调度失败时，将会触发失败报警，如发送报警邮件。 任务调度失败时邮件通知的邮箱地址，支持配置多邮箱地址，配置多个邮箱地址时用逗号分隔 E-Job ： 通过事件订阅方式可自行实现 作业运行状态监控、监听作业服务器存活、监听近期数据处理成功、数据流类型作业（可通过监听近期数据处理成功数判断作业流量是否正常,如果小于作业正常处理的阀值，可选择报警。）、监听近期数据处理失败（可通过监听近期数据处理失败数判断作业处理结果，如果大于0，可选择报警。） 弹性扩容缩容X-Job ： 使用Quartz基于数据库的分布式功能，服务器超出一定数量会给数据库造成一定的压力 E-Job ： 通过zk实现各服务的注册、控制及协调 支持并行调度X-Job ： 调度系统多线程（默认10个线程）触发调度运行，确保调度精确执行，不被堵塞。 E-Job ： 采用任务分片方式实现。将一个任务拆分为n个独立的任务项，由分布式的服务器并行执行各自分配到的分片项。 高可用策略X-Job ： “调度中心”通过DB锁保证集群分布式调度的一致性, 一次任务调度只会触发一次执行； E-Job ： 调度器的高可用是通过运行几个指向同一个ZooKeeper集群的Elastic-Job-Cloud-Scheduler实例来实现的。ZooKeeper用于在当前主Elastic-Job-Cloud-Scheduler实例失败的情况下执行领导者选举。通过至少两个调度器实例来构成集群，集群中只有一个调度器实例提供服务，其他实例处于”待命”状态。当该实例失败时，集群会选举剩余实例中的一个来继续提供服务。 失败处理策略X-Job ： 调度失败时的处理策略，策略包括：失败告警（默认）、失败重试； E-Job ： 弹性扩容缩容在下次作业运行前重分片，但本次作业执行的过程中，下线的服务器所分配的作业将不会重新被分配。失效转移功能可以在本次作业运行中用空闲服务器抓取孤儿作业分片执行。同样失效转移功能也会牺牲部分性能。 动态分片策略X-Job ： 分片广播任务以执行器为维度进行分片，支持动态扩容执行器集群从而动态增加分片数量，协同进行业务处理；在进行大数据量业务操作时可显著提升任务处理能力和速度。 执行器集群部署时，任务路由策略选择”分片广播”情况下，一次任务调度将会广播触发对应集群中所有执行器执行一次任务，同时传递分片参数；可根据分片参数开发分片任务； E-Job ： 支持多种分片策略，可自定义分片策略 默认包含三种分片策略： 基于平均分配算法的分片策略、 作业名的哈希值奇偶数决定IP升降序算法的分片策略、根据作业名的哈希值对Job实例列表进行轮转的分片策略，支持自定义分片策略 elastic-job的分片是通过zookeeper来实现的。分片的分片由主节点分配，如下三种情况都会触发主节点上的分片算法执行： a、新的Job实例加入集群 b、现有的Job实例下线（如果下线的是leader节点，那么先选举然后触发分片算法的执行） c、主节点选举” 和quartz框架对比 调用API的的方式操作任务，不人性化； 需要持久化业务QuartzJobBean到底层数据表中，系统侵入性相当严重。 调度逻辑和QuartzJobBean耦合在同一个项目中，这将导致一个问题，在调度任务数量逐渐增多，同时调度任务逻辑逐渐加重的情况加，此时调度系统的性能将大大受限于业务； Quartz关注点在于定时任务而非数据，并无一套根据数据处理而定制化的流程。虽然Quartz可以基于数据库实现作业的高可用，但缺少分布式并行调度的功能。 综合对比​ 总结和结论共同点： E-Job和X-job都有广泛的用户基础和完整的技术文档，都能满足定时任务的基本功能需求。 不同点 X-Job 侧重的业务实现的简单和管理的方便，学习成本简单，失败策略和路由策略丰富。推荐使用在“用户基数相对少，服务器数量在一定范围内”的情景下使用 E-Job 关注的是数据，增加了弹性扩容和数据分片的思路，以便于更大限度的利用分布式服务器的资源。但是学习成本相对高些，推荐在“数据量庞大，且部署服务器数量较多”时使用"},{"title":"docker 加速器","date":"2019-06-21T17:50:32.000Z","path":"2019/06/22/docker加速器配置/","text":"docker 加速器常用的加速器服务： Docker 官方的中国镜像加速器：从2017年6月9日起，Docker 官方提供了在中国的加速器，以解决墙的问题。不用注册，直接使用加速器地址：https://registry.docker-cn.com 即可。 中国科技大学的镜像加速器：中科大的加速器不用注册，直接使用地址 https://docker.mirrors.ustc.edu.cn/ 配置加速器即可。进一步的信息可以访问：http://mirrors.ustc.edu.cn/help/dockerhub.html?highlight=docker 阿里云加速器：注册阿里云开发账户(免费的)后，访问这个链接就可以看到加速器地址： https://cr.console.aliyun.com/#/accelerator DaoCloud 加速器：注册 DaoCloud 账户(支持微信登录)，然后访问： https://www.daocloud.io/mirror#accelerator-doc Ubuntu 16.04 或 CentOS 7 配置加速器（或其它使用 Systemd 的系统）Ubuntu 16.04 和 CentOS 7 这类系统都已经开始使用 systemd 进行系统初始化管理了，对于使用 systemd 的系统，应该通过编辑服务配置文件 docker.service 来进行加速器的配置。 在启用服务后 1$ sudo systemctl enable docker 可以直接编辑 /etc/systemd/system/multi-user.target.wants/docker.service 文件来进行配置。 1sudo vi /etc/systemd/system/multi-user.target.wants/docker.service 在文件中找到 ExecStart= 这一行，并且在其行尾添加上所需的配置。假设我们的加速器地址为 https://registry.docker-cn.com，那么可以这样配置： 1ExecStart=/usr/bin/dockerd --registry-mirror=https://registry.docker-cn.com 保存退出后，重新加载配置并启动服务： 12sudo systemctl daemon-reloadsudo systemctl restart docker 确认一下配置是否已经生效： 1sudo ps -ef | grep dockerd 如果配置成功，生效后就会在这里看到自己所配置的加速器。 Ubuntu 14.04 配置加速器（或其它使用 Upstart 的系统）Ubuntu 14.04 是使用 upstart 进行系统初始化的，对于这类系统，可以用通过编辑配置文件的方法来配置加速器。 如果是 Ubuntu 14.04，那么编辑 /etc/default/docker，在里面寻找 DOCKER_OPTS 环境变量设置的这一行，在其后添加 -–registry-mirror=&lt;加速器地址&gt;。如果发现该行已被注释，或者不存在该行，那么新添一行即可。 比如，在使用官方源安装了 docker-engine 后，会建立一个默认的 /etc/default/docker，其中相关 DOCKER_OPTS 的行是这样的： 12# Use DOCKER_OPTS to modify the daemon startup options.#DOCKER_OPTS=&quot;--dns 8.8.8.8 --dns 8.8.4.4&quot; 假设我们的加速器地址为 https://registry.docker-cn.com，我们添加一行配置，将其改为： 123# Use DOCKER_OPTS to modify the daemon startup options.#DOCKER_OPTS=&quot;--dns 8.8.8.8 --dns 8.8.4.4&quot;DOCKER_OPTS=&quot;--registry-mirror=https://registry.docker-cn.com&quot; 保存文件后，重启 Docker 引擎： 123$ sudo service docker restartdocker stop/waitingdocker start/running, process 3620 重启成功后，确认一下配置是否已经生效： 12$ sudo ps -ef | grep dockerdroot 3620 1 0 04:26 ? 00:00:00 /usr/bin/dockerd --registry-mirror=https://registry.docker-cn.com --raw-logs 如果配置成功，生效后这里就会看到自己所配置的加速器的内容。"},{"title":"非root用户运行docker","date":"2019-06-21T17:50:32.000Z","path":"2019/06/22/非root用户运行docker/","text":"非root用户运行docker1、 首先创建docker用户组，如果docker用户组存在可以忽略 1sudo groupadd docker 2、把用户添加进docker组中 1sudo gpasswd -a $&#123;USER&#125; docker 3、重启docker 1sudo service docker restart 4、如果普通用户执行docker命令，如果提示get …… dial unix /var/run/docker.sock权限不够，则修改/var/run/docker.sock权限使用root用户执行如下命令，即可 1sudo chmod a+rw /var/run/docker.sock"},{"title":"Docker安装gitlab","date":"2019-06-21T17:50:32.000Z","path":"2019/06/22/Docker容器日志清理/","text":"Docker容器日志清理清理Docker容器日志（治标）新建日志清理脚本clean_docker_log.sh，内容如下： 123456789#!/bin/shecho \"======== start clean docker containers logs ========\"logs=$(find /var/lib/docker/containers/ -name *-json.log)for log in $logs do echo \"clean logs : $log\" cat /dev/null &gt; $log doneecho \"======== end clean docker containers logs ========\" 12# chmod +x clean_docker_log.sh# ./clean_docker_log.sh 设置Docker容器日志大小（治本）设置一个容器服务的日志大小上限上述方法，日志文件迟早又会涨回来。要从根本上解决问题，需要限制容器服务的日志大小上限。这个通过配置容器docker-compose的max-size选项来实现 1234567nginx: image: nginx:1.12.1 restart: always logging: driver: “json-file” options: max-size: “5g” 重启nginx容器之后，其日志文件的大小就被限制在5GB，再也不用担心了。 全局设置新建/etc/docker/daemon.json，若有就不用新建了。添加log-dirver和log-opts参数，样例如下： 123456# vim /etc/docker/daemon.json&#123; &quot;log-driver&quot;:&quot;json-file&quot;, &quot;log-opts&quot;: &#123;&quot;max-size&quot;:&quot;500m&quot;, &quot;max-file&quot;:&quot;3&quot;&#125;&#125; max-size=500m，意味着一个容器日志大小上限是500M，max-file=3，意味着一个容器有三个日志，分别是id+.json、id+1.json、id+2.json。 123// 重启docker守护进程# systemctl daemon-reload# systemctl restart docker"},{"title":"Docker安装gitlab","date":"2019-06-21T17:50:32.000Z","path":"2019/06/22/docker安装gitlab/","text":"Docker安装gitlab1、docker-compose.yaml123456789101112131415version: '3.0'services: gitlab: image: gitlab/gitlab-ce restart: always container_name: gitlab ports: - \"10443:443\" - \"10080:80\" - \"10022:22\" volumes: - /usr/share/zoneinfo/Asia/Shanghai:/etc/localtime:ro - ./gitlab/config:/etc/gitlab - ./gitlab/logs:/var/log/gitlab - ./gitlab/data:/var/opt/gitlab 2、修改gitlab.rb文件1）把external_url改成部署机器的域名或者IP地址1vim ./gitlab/config/gitlab.rb 12345# 配置http协议所使用的访问地址,不加端口号默认为80external_url 'http://git.sxp.com'# 配置ssh协议所使用的访问地址和端口gitlab_rails['gitlab_ssh_host'] = 'git.sxp.com'gitlab_rails['gitlab_shell_ssh_port'] = 10023 # 此端口是run时22端口映射的10022端口 2）启用https支持1vim ./gitlab/config/gitlab.rb 1234external_url 'http://git.sxp.com'nginx['redirect_http_to_https'] = truenginx['ssl_certificate'] = \"/etc/gitlab/ssl/sxp.com.pem\"nginx['ssl_certificate_key'] = \"/etc/gitlab/ssl/sxp.com.key\" 3）配置邮件发送功能1vim ./gitlab/config/gitlab.rb 阿里云邮箱12345678910111213gitlab_rails['smtp_enable'] = truegitlab_rails['smtp_address'] = \"smtp.sxp.com\"gitlab_rails['smtp_port'] = 465gitlab_rails['smtp_user_name'] = \"sxp@sxp.com\"gitlab_rails['smtp_password'] = \"12345678\"gitlab_rails['smtp_domain'] = \"smtp.sxp.com\"gitlab_rails['smtp_authentication'] = \"login\"gitlab_rails['smtp_enable_starttls_auto'] = truegitlab_rails['smtp_tls'] = truegitlab_rails['smtp_openssl_verify_mode'] = 'none'gitlab_rails['gitlab_email_from'] = 'sxp@sxp.com'user['git_user_email'] = \"sxp@sxp.com\" ####"},{"title":"Linux 安装 docker","date":"2019-06-21T17:50:32.000Z","path":"2019/06/22/安装docker/","text":"Linux 安装 docker手动安装帮助 (阿里云ECS可以通过内网安装，见注释部分内容)CentOS 7 (使用yum进行安装)123456789101112131415161718192021222324252627282930313233343536# step 1: 安装必要的一些系统工具sudo yum updatesudo yum install -y yum-utils device-mapper-persistent-data lvm2# Step 2: 添加软件源信息sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo# Step 3: 更新并安装 Docker-CEsudo yum makecache fastsudo yum -y install docker-ce# Step 4: 开启Docker服务sudo service docker start注意：其他注意事项在下面的注释中# 官方软件源默认启用了最新的软件，您可以通过编辑软件源的方式获取各个版本的软件包。例如官方并没有将测试版本的软件源置为可用，你可以通过以下方式开启。同理可以开启各种测试版本等。# vim /etc/yum.repos.d/docker-ce.repo# 将 [docker-ce-test] 下方的 enabled=0 修改为 enabled=1## 安装指定版本的Docker-CE:# Step 1: 查找Docker-CE的版本:# yum list docker-ce.x86_64 --showduplicates | sort -r# Loading mirror speeds from cached hostfile# Loaded plugins: branch, fastestmirror, langpacks# docker-ce.x86_64 17.03.1.ce-1.el7.centos docker-ce-stable# docker-ce.x86_64 17.03.1.ce-1.el7.centos @docker-ce-stable# docker-ce.x86_64 17.03.0.ce-1.el7.centos docker-ce-stable# Available Packages# Step2 : 安装指定版本的Docker-CE: (VERSION 例如上面的 17.03.0.ce.1-1.el7.centos)# sudo yum -y install docker-ce-[VERSION]# 注意：在某些版本之后，docker-ce安装出现了其他依赖包，如果安装失败的话请关注错误信息。例如 docker-ce 17.03 之后，需要先安装 docker-ce-selinux。# yum list docker-ce-selinux- --showduplicates | sort -r# sudo yum -y install docker-ce-selinux-[VERSION]# 通过经典网络、VPC网络内网安装时，用以下命令替换Step 2中的命令# 经典网络：# sudo yum-config-manager --add-repo http://mirrors.aliyuncs.com/docker-ce/linux/centos/docker-ce.repo# VPC网络：# sudo yum-config-manager --add-repo http://mirrors.could.aliyuncs.com/docker-ce/linux/centos/docker-ce.repo Ubuntu 14.04 16.04 (使用apt-get进行安装)123456789101112131415161718192021222324252627# step 1: 安装必要的一些系统工具sudo apt-get updatesudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common# step 2: 安装GPG证书curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -# Step 3: 写入软件源信息sudo add-apt-repository \"deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable\"# Step 4: 更新并安装 Docker-CEsudo apt-get -y updatesudo apt-get -y install docker-ce注意：其他注意事项在下面的注释中# 安装指定版本的Docker-CE:# Step 1: 查找Docker-CE的版本:# apt-cache madison docker-ce# docker-ce | 17.03.1~ce-0~ubuntu-xenial | http://mirrors.aliyun.com/docker-ce/linux/ubuntu xenial/stable amd64 Packages# docker-ce | 17.03.0~ce-0~ubuntu-xenial | http://mirrors.aliyun.com/docker-ce/linux/ubuntu xenial/stable amd64 Packages# Step 2: 安装指定版本的Docker-CE: (VERSION 例如上面的 17.03.1~ce-0~ubuntu-xenial)# sudo apt-get -y install docker-ce=[VERSION]# 通过经典网络、VPC网络内网安装时，用以下命令替换Step 2、Step 3中的命令# 经典网络：# curl -fsSL http://mirrors.aliyuncs.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -# sudo add-apt-repository \"deb [arch=amd64] http://mirrors.aliyuncs.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable\"# VPC网络：# curl -fsSL http://mirrors.cloud.aliyuncs.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -# sudo add-apt-repository \"deb [arch=amd64] http://mirrors.cloud.aliyuncs.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable\" 使用官方安装脚本自动安装 （仅适用于公网环境）1curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun"},{"title":"安装docker-compose","date":"2019-06-21T17:50:32.000Z","path":"2019/06/22/安装docker-compose/","text":"安装docker-compose1sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.24.0/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose 1sudo chmod +x /usr/local/bin/docker-compose"},{"title":"任务调度的 Java 实现方法与比较","date":"2019-06-21T17:50:32.000Z","path":"2019/06/22/任务调度的 Java 实现方法与比较/","text":"#任务调度的 Java 实现方法与比较 前言任务调度是指基于给定时间点，给定时间间隔或者给定执行次数自动执行任务。本文由浅入深介绍四种任务调度的 Java 实现： Timer ScheduledExecutor 开源工具包 Quartz 开源工具包 JCronTab 此外，为结合实现复杂的任务调度，本文还将介绍 Calendar 的一些使用方法。 Timer相信大家都已经非常熟悉 java.util.Timer 了，它是最简单的一种实现任务调度的方法，下面给出一个具体的例子： 清单 1. 使用 Timer 进行任务调度1`package com.ibm.scheduler; ``import java.util.Timer; ``import java.util.TimerTask; ` `public class TimerTest extends TimerTask &#123; ` `private String jobName = &quot;&quot;; ` `public TimerTest(String jobName) &#123; ``super(); ``this.jobName = jobName; ``&#125; ` `@Override ``public void run() &#123; ``System.out.println(&quot;execute &quot; + jobName); ``&#125; ` `public static void main(String[] args) &#123; ``Timer timer = new Timer(); ``long delay1 = 1 * 1000; ``long period1 = 1000; ``// 从现在开始 1 秒钟之后，每隔 1 秒钟执行一次 job1 ``timer.schedule(new TimerTest(&quot;job1&quot;), delay1, period1); ``long delay2 = 2 * 1000; ``long period2 = 2000; ``// 从现在开始 2 秒钟之后，每隔 2 秒钟执行一次 job2 ``timer.schedule(new TimerTest(&quot;job2&quot;), delay2, period2); ``&#125; ``&#125; ``Output: ``execute job1 ``execute job1 ``execute job2 ``execute job1 ``execute job1 ``execute job2` 使用 Timer 实现任务调度的核心类是 Timer 和 TimerTask。其中 Timer 负责设定 TimerTask 的起始与间隔执行时间。使用者只需要创建一个 TimerTask 的继承类，实现自己的 run 方法，然后将其丢给 Timer 去执行即可。 Timer 的设计核心是一个 TaskList 和一个 TaskThread。Timer 将接收到的任务丢到自己的 TaskList 中，TaskList 按照 Task 的最初执行时间进行排序。TimerThread 在创建 Timer 时会启动成为一个守护线程。这个线程会轮询所有任务，找到一个最近要执行的任务，然后休眠，当到达最近要执行任务的开始时间点，TimerThread 被唤醒并执行该任务。之后 TimerThread 更新最近一个要执行的任务，继续休眠。 Timer 的优点在于简单易用，但由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行，前一个任务的延迟或异常都将会影响到之后的任务。 ScheduledExecutor鉴于 Timer 的上述缺陷，Java 5 推出了基于线程池设计的 ScheduledExecutor。其设计思想是，每一个被调度的任务都会由线程池中一个线程去执行，因此任务是并发执行的，相互之间不会受到干扰。需要注意的是，只有当任务的执行时间到来时，ScheduedExecutor 才会真正启动一个线程，其余时间 ScheduledExecutor 都是在轮询任务的状态。 清单 2. 使用 ScheduledExecutor 进行任务调度1`package com.ibm.scheduler;``import java.util.concurrent.Executors;``import java.util.concurrent.ScheduledExecutorService;``import java.util.concurrent.TimeUnit;` `public class ScheduledExecutorTest implements Runnable &#123;`` ``private String jobName = &quot;&quot;;` ` ``public ScheduledExecutorTest(String jobName) &#123;`` ``super();`` ``this.jobName = jobName;`` ``&#125;` ` ``@Override`` ``public void run() &#123;`` ``System.out.println(&quot;execute &quot; + jobName);`` ``&#125;` ` ``public static void main(String[] args) &#123;`` ``ScheduledExecutorService service = Executors.newScheduledThreadPool(10);` ` ``long initialDelay1 = 1;`` ``long period1 = 1;`` ``// 从现在开始1秒钟之后，每隔1秒钟执行一次job1`` ``service.scheduleAtFixedRate(`` ``new ScheduledExecutorTest(&quot;job1&quot;), initialDelay1,`` ``period1, TimeUnit.SECONDS);` ` ``long initialDelay2 = 1;`` ``long delay2 = 1;`` ``// 从现在开始2秒钟之后，每隔2秒钟执行一次job2`` ``service.scheduleWithFixedDelay(`` ``new ScheduledExecutorTest(&quot;job2&quot;), initialDelay2,`` ``delay2, TimeUnit.SECONDS);`` ``&#125;``&#125;``Output:``execute job1``execute job1``execute job2``execute job1``execute job1``execute job2` 清单 2 展示了 ScheduledExecutorService 中两种最常用的调度方法 ScheduleAtFixedRate 和 ScheduleWithFixedDelay。ScheduleAtFixedRate 每次执行时间为上一次任务开始起向后推一个时间间隔，即每次执行时间为 :initialDelay, initialDelay+period, initialDelay+2period, …；ScheduleWithFixedDelay 每次执行时间为上一次任务结束起向后推一个时间间隔，即每次执行时间为：initialDelay, initialDelay+executeTime+delay, initialDelay+2executeTime+2*delay。由此可见，ScheduleAtFixedRate 是基于固定时间间隔进行任务调度，ScheduleWithFixedDelay 取决于每次任务执行的时间长短，是基于不固定时间间隔进行任务调度。 用 ScheduledExecutor 和 Calendar 实现复杂任务调度Timer 和 ScheduledExecutor 都仅能提供基于开始时间与重复间隔的任务调度，不能胜任更加复杂的调度需求。比如，设置每星期二的 16:38:10 执行任务。该功能使用 Timer 和 ScheduledExecutor 都不能直接实现，但我们可以借助 Calendar 间接实现该功能。 清单 3. 使用 ScheduledExcetuor 和 Calendar 进行任务调度1`package com.ibm.scheduler;` `import java.util.Calendar;``import java.util.Date;``import java.util.TimerTask;``import java.util.concurrent.Executors;``import java.util.concurrent.ScheduledExecutorService;``import java.util.concurrent.TimeUnit;` `public class ScheduledExceutorTest2 extends TimerTask &#123;` ` ``private String jobName = &quot;&quot;;` ` ``public ScheduledExceutorTest2(String jobName) &#123;`` ``super();`` ``this.jobName = jobName;`` ``&#125;` ` ``@Override`` ``public void run() &#123;`` ``System.out.println(&quot;Date = &quot;+new Date()+&quot;, execute &quot; + jobName);`` ``&#125;` ` ``/**`` ``* 计算从当前时间currentDate开始，满足条件dayOfWeek, hourOfDay, `` ``* minuteOfHour, secondOfMinite的最近时间`` ``* @return`` ``*/`` ``public Calendar getEarliestDate(Calendar currentDate, int dayOfWeek,`` ``int hourOfDay, int minuteOfHour, int secondOfMinite) &#123;`` ``//计算当前时间的WEEK_OF_YEAR,DAY_OF_WEEK, HOUR_OF_DAY, MINUTE,SECOND等各个字段值`` ``int currentWeekOfYear = currentDate.get(Calendar.WEEK_OF_YEAR);`` ``int currentDayOfWeek = currentDate.get(Calendar.DAY_OF_WEEK);`` ``int currentHour = currentDate.get(Calendar.HOUR_OF_DAY);`` ``int currentMinute = currentDate.get(Calendar.MINUTE);`` ``int currentSecond = currentDate.get(Calendar.SECOND);` ` ``//如果输入条件中的dayOfWeek小于当前日期的dayOfWeek,则WEEK_OF_YEAR需要推迟一周`` ``boolean weekLater = false;`` ``if (dayOfWeek &lt; currentDayOfWeek) &#123;`` ``weekLater = true;`` ``&#125; else if (dayOfWeek == currentDayOfWeek) &#123;`` ``//当输入条件与当前日期的dayOfWeek相等时，如果输入条件中的`` ``//hourOfDay小于当前日期的`` ``//currentHour，则WEEK_OF_YEAR需要推迟一周 `` ``if (hourOfDay &lt; currentHour) &#123;`` ``weekLater = true;`` ``&#125; else if (hourOfDay == currentHour) &#123;`` ``//当输入条件与当前日期的dayOfWeek, hourOfDay相等时，`` ``//如果输入条件中的minuteOfHour小于当前日期的`` ``//currentMinute，则WEEK_OF_YEAR需要推迟一周`` ``if (minuteOfHour &lt; currentMinute) &#123;`` ``weekLater = true;`` ``&#125; else if (minuteOfHour == currentSecond) &#123;`` ``//当输入条件与当前日期的dayOfWeek, hourOfDay， `` ``//minuteOfHour相等时，如果输入条件中的`` ``//secondOfMinite小于当前日期的currentSecond，`` ``//则WEEK_OF_YEAR需要推迟一周`` ``if (secondOfMinite &lt; currentSecond) &#123;`` ``weekLater = true;`` ``&#125;`` ``&#125;`` ``&#125;`` ``&#125;`` ``if (weekLater) &#123;`` ``//设置当前日期中的WEEK_OF_YEAR为当前周推迟一周`` ``currentDate.set(Calendar.WEEK_OF_YEAR, currentWeekOfYear + 1);`` ``&#125;`` ``// 设置当前日期中的DAY_OF_WEEK,HOUR_OF_DAY,MINUTE,SECOND为输入条件中的值。`` ``currentDate.set(Calendar.DAY_OF_WEEK, dayOfWeek);`` ``currentDate.set(Calendar.HOUR_OF_DAY, hourOfDay);`` ``currentDate.set(Calendar.MINUTE, minuteOfHour);`` ``currentDate.set(Calendar.SECOND, secondOfMinite);`` ``return currentDate;` ` ``&#125;` ` ``public static void main(String[] args) throws Exception &#123;` ` ``ScheduledExceutorTest2 test = new ScheduledExceutorTest2(&quot;job1&quot;);`` ``//获取当前时间`` ``Calendar currentDate = Calendar.getInstance();`` ``long currentDateLong = currentDate.getTime().getTime();`` ``System.out.println(&quot;Current Date = &quot; + currentDate.getTime().toString());`` ``//计算满足条件的最近一次执行时间`` ``Calendar earliestDate = test`` ``.getEarliestDate(currentDate, 3, 16, 38, 10);`` ``long earliestDateLong = earliestDate.getTime().getTime();`` ``System.out.println(&quot;Earliest Date = &quot;`` ``+ earliestDate.getTime().toString());`` ``//计算从当前时间到最近一次执行时间的时间间隔`` ``long delay = earliestDateLong - currentDateLong;`` ``//计算执行周期为一星期`` ``long period = 7 * 24 * 60 * 60 * 1000;`` ``ScheduledExecutorService service = Executors.newScheduledThreadPool(10);`` ``//从现在开始delay毫秒之后，每隔一星期执行一次job1`` ``service.scheduleAtFixedRate(test, delay, period,`` ``TimeUnit.MILLISECONDS);` ` ``&#125;``&#125; ``Output:``Current Date = Wed Feb 02 17:32:01 CST 2011``Earliest Date = Tue Feb 8 16:38:10 CST 2011``Date = Tue Feb 8 16:38:10 CST 2011, execute job1``Date = Tue Feb 15 16:38:10 CST 2011, execute job1` 清单 3 实现了每星期二 16:38:10 调度任务的功能。其核心在于根据当前时间推算出最近一个星期二 16:38:10 的绝对时间，然后计算与当前时间的时间差，作为调用 ScheduledExceutor 函数的参数。计算最近时间要用到 java.util.calendar 的功能。首先需要解释 calendar 的一些设计思想。Calendar 有以下几种唯一标识一个日期的组合方式： 1`YEAR + MONTH + DAY_OF_MONTH ``YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK ``YEAR + MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK ``YEAR + DAY_OF_YEAR ``YEAR + DAY_OF_WEEK + WEEK_OF_YEAR` 上述组合分别加上 HOUR_OF_DAY + MINUTE + SECOND 即为一个完整的时间标识。本例采用了最后一种组合方式。输入为 DAY_OF_WEEK, HOUR_OF_DAY, MINUTE, SECOND 以及当前日期 , 输出为一个满足 DAY_OF_WEEK, HOUR_OF_DAY, MINUTE, SECOND 并且距离当前日期最近的未来日期。计算的原则是从输入的 DAY_OF_WEEK 开始比较，如果小于当前日期的 DAY_OF_WEEK，则需要向 WEEK_OF_YEAR 进一， 即将当前日期中的 WEEK_OF_YEAR 加一并覆盖旧值；如果等于当前的 DAY_OF_WEEK, 则继续比较 HOUR_OF_DAY；如果大于当前的 DAY_OF_WEEK，则直接调用 java.util.calenda 的 calendar.set(field, value) 函数将当前日期的 DAY_OF_WEEK, HOUR_OF_DAY, MINUTE, SECOND 赋值为输入值，依次类推，直到比较至 SECOND。读者可以根据输入需求选择不同的组合方式来计算最近执行时间。 可以看出，用上述方法实现该任务调度比较麻烦，这就需要一个更加完善的任务调度框架来解决这些复杂的调度问题。幸运的是，开源工具包 Quartz 与 JCronTab 提供了这方面强大的支持。 QuartzQuartz 可以满足更多更复杂的调度需求，首先让我们看看如何用 Quartz 实现每星期二 16:38 的调度安排： 清单 4. 使用 Quartz 进行任务调度1`package com.ibm.scheduler;``import java.util.Date;` `import org.quartz.Job;``import org.quartz.JobDetail;``import org.quartz.JobExecutionContext;``import org.quartz.JobExecutionException;``import org.quartz.Scheduler;``import org.quartz.SchedulerFactory;``import org.quartz.Trigger;``import org.quartz.helpers.TriggerUtils;` `public class QuartzTest implements Job &#123;` ` ``@Override`` ``//该方法实现需要执行的任务`` ``public void execute(JobExecutionContext arg0) throws JobExecutionException &#123;`` ``System.out.println(&quot;Generating report - &quot;`` ``+ arg0.getJobDetail().getFullName() + &quot;, type =&quot;`` ``+ arg0.getJobDetail().getJobDataMap().get(&quot;type&quot;));`` ``System.out.println(new Date().toString());`` ``&#125;`` ``public static void main(String[] args) &#123;`` ``try &#123;`` ``// 创建一个Scheduler`` ``SchedulerFactory schedFact = `` ``new org.quartz.impl.StdSchedulerFactory();`` ``Scheduler sched = schedFact.getScheduler();`` ``sched.start();`` ``// 创建一个JobDetail，指明name，groupname，以及具体的Job类名，`` ``//该Job负责定义需要执行任务`` ``JobDetail jobDetail = new JobDetail(&quot;myJob&quot;, &quot;myJobGroup&quot;,`` ``QuartzTest.class);`` ``jobDetail.getJobDataMap().put(&quot;type&quot;, &quot;FULL&quot;);`` ``// 创建一个每周触发的Trigger，指明星期几几点几分执行`` ``Trigger trigger = TriggerUtils.makeWeeklyTrigger(3, 16, 38);`` ``trigger.setGroup(&quot;myTriggerGroup&quot;);`` ``// 从当前时间的下一秒开始执行`` ``trigger.setStartTime(TriggerUtils.getEvenSecondDate(new Date()));`` ``// 指明trigger的name`` ``trigger.setName(&quot;myTrigger&quot;);`` ``// 用scheduler将JobDetail与Trigger关联在一起，开始调度任务`` ``sched.scheduleJob(jobDetail, trigger);` ` ``&#125; catch (Exception e) &#123;`` ``e.printStackTrace();`` ``&#125;`` ``&#125;``&#125; ``Output:``Generating report - myJobGroup.myJob, type =FULL``Tue Feb 8 16:38:00 CST 2011``Generating report - myJobGroup.myJob, type =FULL``Tue Feb 15 16:38:00 CST 2011` 清单 4 非常简洁地实现了一个上述复杂的任务调度。Quartz 设计的核心类包括 Scheduler, Job 以及 Trigger。其中，Job 负责定义需要执行的任务，Trigger 负责设置调度策略，Scheduler 将二者组装在一起，并触发任务开始执行。 Job使用者只需要创建一个 Job 的继承类，实现 execute 方法。JobDetail 负责封装 Job 以及 Job 的属性，并将其提供给 Scheduler 作为参数。每次 Scheduler 执行任务时，首先会创建一个 Job 的实例，然后再调用 execute 方法执行。Quartz 没有为 Job 设计带参数的构造函数，因此需要通过额外的 JobDataMap 来存储 Job 的属性。JobDataMap 可以存储任意数量的 Key，Value 对，例如： 清单 5. 为 JobDataMap 赋值1`jobDetail.getJobDataMap().put(&quot;myDescription&quot;, &quot;my job description&quot;); ``jobDetail.getJobDataMap().put(&quot;myValue&quot;, 1998); ``ArrayList&lt;``String``&gt; list = new ArrayList&lt;``String``&gt;(); ``list.add(&quot;item1&quot;); ``jobDetail.getJobDataMap().put(&quot;myArray&quot;, list);` JobDataMap 中的数据可以通过下面的方式获取： 清单 6. 获取 JobDataMap 的值1`public class JobDataMapTest implements Job &#123;` ` ``@Override`` ``public void execute(JobExecutionContext context)`` ``throws JobExecutionException &#123;`` ``//从context中获取instName，groupName以及dataMap`` ``String instName = context.getJobDetail().getName();`` ``String groupName = context.getJobDetail().getGroup();`` ``JobDataMap dataMap = context.getJobDetail().getJobDataMap();`` ``//从dataMap中获取myDescription，myValue以及myArray`` ``String myDescription = dataMap.getString(&quot;myDescription&quot;);`` ``int myValue = dataMap.getInt(&quot;myValue&quot;);`` ``ArrayList&lt;``String``&gt; myArray = (ArrayListlt;Strin&gt;) dataMap.get(&quot;myArray&quot;);`` ``System.out.println(&quot;`` ``Instance =&quot; + instName + &quot;, group = &quot; + groupName`` ``+ &quot;, description = &quot; + myDescription + &quot;, value =&quot; + myValue`` ``+ &quot;, array item0 = &quot; + myArray.get(0));` ` ``&#125;``&#125;``Output：``Instance = myJob, group = myJobGroup, ``description = my job description, ``value =1998, array item0 = item1` TriggerTrigger 的作用是设置调度策略。Quartz 设计了多种类型的 Trigger，其中最常用的是 SimpleTrigger 和 CronTrigger。 SimpleTrigger 适用于在某一特定的时间执行一次，或者在某一特定的时间以某一特定时间间隔执行多次。上述功能决定了 SimpleTrigger 的参数包括 start-time, end-time, repeat count, 以及 repeat interval。 Repeat count 取值为大于或等于零的整数，或者常量 SimpleTrigger.REPEAT_INDEFINITELY。 Repeat interval 取值为大于或等于零的长整型。当 Repeat interval 取值为零并且 Repeat count 取值大于零时，将会触发任务的并发执行。 Start-time 与 dnd-time 取值为 java.util.Date。当同时指定 end-time 与 repeat count 时，优先考虑 end-time。一般地，可以指定 end-time，并设定 repeat count 为 REPEAT_INDEFINITELY。 以下是 SimpleTrigger 的构造方法： 1`public SimpleTrigger(String name, `` ``String group, `` ``Date startTime, `` ``Date endTime, `` ``int repeatCount, `` ``long repeatInterval)` 举例如下： 创建一个立即执行且仅执行一次的 SimpleTrigger： 1`SimpleTrigger trigger=``new SimpleTrigger(&quot;myTrigger&quot;, &quot;myGroup&quot;, new Date(), null, 0, 0L);` 创建一个半分钟后开始执行，且每隔一分钟重复执行一次的 SimpleTrigger： 1`SimpleTrigger trigger=``new SimpleTrigger(&quot;myTrigger&quot;, &quot;myGroup&quot;, `` ``new Date(System.currentTimeMillis()+30*1000), null, 0, 60*1000);` 创建一个 2011 年 6 月 1 日 8:30 开始执行，每隔一小时执行一次，一共执行一百次，一天之后截止的 SimpleTrigger： 1`Calendar calendar = Calendar.getInstance(); ``calendar.set(Calendar.YEAR, 2011); ``calendar.set(Calendar.MONTH, Calendar.JUNE); ``calendar.set(Calendar.DAY_OF_MONTH, 1); ``calendar.set(Calendar.HOUR, 8); ``calendar.set(Calendar.MINUTE, 30); ``calendar.set(Calendar.SECOND, 0); ``calendar.set(Calendar.MILLISECOND, 0); ``Date startTime = calendar.getTime(); ``Date endTime = new Date (calendar.getTimeInMillis() +24*60*60*1000); ``SimpleTrigger trigger=new SimpleTrigger(&quot;myTrigger&quot;, `` ``&quot;myGroup&quot;, startTime, endTime, 100, 60*60*1000);` 上述最后一个例子中，同时设置了 end-time 与 repeat count，则优先考虑 end-time，总共可以执行二十四次。 CronTrigger 的用途更广，相比基于特定时间间隔进行调度安排的 SimpleTrigger，CronTrigger 主要适用于基于日历的调度安排。例如：每星期二的 16:38:10 执行，每月一号执行，以及更复杂的调度安排等。 CronTrigger 同样需要指定 start-time 和 end-time，其核心在于 Cron 表达式，由七个字段组成： 1`Seconds ``Minutes ``Hours ``Day-of-Month ``Month ``Day-of-Week ``Year (Optional field)` 举例如下： 创建一个每三小时执行的 CronTrigger，且从每小时的整点开始执行： 1`0 0 0/3 * * ?` 创建一个每十分钟执行的 CronTrigger，且从每小时的第三分钟开始执行： 1`0 3/10 * * * ?` 创建一个每周一，周二，周三，周六的晚上 20:00 到 23:00，每半小时执行一次的 CronTrigger： 1`0 0/30 20-23 ? * MON-WED,SAT` 创建一个每月最后一个周四，中午 11:30-14:30，每小时执行一次的 trigger： 1`0 30 11-14/1 ? * 5L` 解释一下上述例子中各符号的含义： 首先所有字段都有自己特定的取值，例如，Seconds 和 Minutes 取值为 0 到 59，Hours 取值为 0 到 23，Day-of-Month 取值为 0-31, Month 取值为 0-11，或者 JAN，FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC，Days-of-Week 取值为 1-7 或者 SUN, MON, TUE, WED, THU, FRI, SAT。每个字段可以取单个值，多个值，或一个范围，例如 Day-of-Week 可取值为“MON，TUE，SAT”,“MON-FRI”或者“TUE-THU，SUN”。 通配符 * 表示该字段可接受任何可能取值。例如 Month 字段赋值 * 表示每个月，Day-of-Week 字段赋值 * 表示一周的每天。 / 表示开始时刻与间隔时段。例如 Minutes 字段赋值 2/10 表示在一个小时内每 20 分钟执行一次，从第 2 分钟开始。 ? 仅适用于 Day-of-Month 和 Day-of-Week。? 表示对该字段不指定特定值。适用于需要对这两个字段中的其中一个指定值，而对另一个不指定值的情况。一般情况下，这两个字段只需对一个赋值。 L 仅适用于 Day-of-Month 和 Day-of-Week。L 用于 Day-of-Month 表示该月最后一天。L 单独用于 Day-of-Week 表示周六，否则表示一个月最后一个星期几，例如 5L 或者 THUL 表示该月最后一个星期四。 W 仅适用于 Day-of-Month，表示离指定日期最近的一个工作日，例如 Day-of-Month 赋值为 10W 表示该月离 10 号最近的一个工作日。 # 仅适用于 Day-of-Week，表示该月第 XXX 个星期几。例如 Day-of-Week 赋值为 5#2 或者 THU#2，表示该月第二个星期四。 CronTrigger 的使用如下： 1`CronTrigger cronTrigger = new CronTrigger(&quot;myTrigger&quot;, &quot;myGroup&quot;); ``try &#123; `` ``cronTrigger.setCronExpression(&quot;0 0/30 20-13 ? * MON-WED,SAT&quot;); ``&#125; catch (Exception e) &#123; `` ``e.printStackTrace(); ``&#125;` Job 与 Trigger 的松耦合设计是 Quartz 的一大特点，其优点在于同一个 Job 可以绑定多个不同的 Trigger，同一个 Trigger 也可以调度多个 Job，灵活性很强。 Listener除了上述基本的调度功能，Quartz 还提供了 listener 的功能。主要包含三种 listener：JobListener，TriggerListener 以及 SchedulerListener。当系统发生故障，相关人员需要被通知时，Listener 便能发挥它的作用。最常见的情况是，当任务被执行时，系统发生故障，Listener 监听到错误，立即发送邮件给管理员。下面给出 JobListener 的实例： 清单 7. JobListener 的实现1`import org.quartz.JobExecutionContext;``import org.quartz.JobExecutionException;``import org.quartz.JobListener;``import org.quartz.SchedulerException;` `public class MyListener implements JobListener&#123;` ` ``@Override`` ``public String getName() &#123;`` ``return &quot;My Listener&quot;;`` ``&#125;`` ``@Override`` ``public void jobWasExecuted(JobExecutionContext context,`` ``JobExecutionException jobException) &#123;`` ``if(jobException != null)&#123;`` ``try &#123;`` ``//停止Scheduler`` ``context.getScheduler().shutdown();`` ``System.out.println(&quot;`` ``Error occurs when executing jobs, shut down the scheduler &quot;);`` ``// 给管理员发送邮件…`` ``&#125; catch (SchedulerException e) &#123;`` ``e.printStackTrace();`` ``&#125;`` ``&#125;`` ``&#125;``&#125;` 从清单 7 可以看出，使用者只需要创建一个 JobListener 的继承类，重载需要触发的方法即可。当然，需要将 listener 的实现类注册到 Scheduler 和 JobDetail 中： 1`sched.addJobListener(new MyListener()); ``jobDetail.addJobListener(&quot;My Listener&quot;); // listener 的名字` 使用者也可以将 listener 注册为全局 listener，这样便可以监听 scheduler 中注册的所有任务 : 1`sched.addGlobalJobListener(new MyListener());` 为了测试 listener 的功能，可以在 job 的 execute 方法中强制抛出异常。清单 7 中，listener 接收到异常，将 job 所在的 scheduler 停掉，阻止后续的 job 继续执行。scheduler、jobDetail 等信息都可以从 listener 的参数 context 中检索到。 清单 7 的输出结果为： 1`Generating report - myJob.myJob, type =FULL `` ``Tue Feb 15 18:57:35 CST 2011 `` ``2011-2-15 18:57:35 org.quartz.core.JobRunShell run ``信息 : Job myJob.myJob threw a JobExecutionException: `` ``org.quartz.JobExecutionException `` ``at com.ibm.scheduler.QuartzListenerTest.execute(QuartzListenerTest.java:22) `` ``at org.quartz.core.JobRunShell.run(JobRunShell.java:191) `` ``at org.quartz.simpl.SimpleThreadPool$WorkerThread.run(SimpleThreadPool.java:516) `` ``2011-2-15 18:57:35 org.quartz.core.QuartzScheduler shutdown ``信息 : Scheduler DefaultQuartzScheduler_$_NON_CLUSTERED shutting down. `` ``Error occurs when executing jobs, shut down the scheduler` TriggerListener、SchedulerListener 与 JobListener 有类似的功能，只是各自触发的事件不同，如 JobListener 触发的事件为： Job to be executed, Job has completed execution 等 TriggerListener 触发的事件为： Trigger firings, trigger mis-firings, trigger completions 等 SchedulerListener 触发的事件为： add a job/trigger, remove a job/trigger, shutdown a scheduler 等 读者可以根据自己的需求重载相应的事件。 JobStoresQuartz 的另一显著优点在于持久化，即将任务调度的相关数据保存下来。这样，当系统重启后，任务被调度的状态依然存在于系统中，不会丢失。默认情况下，Quartz 采用的是 org.quartz.simpl.RAMJobStore，在这种情况下，数据仅能保存在内存中，系统重启后会全部丢失。若想持久化数据，需要采用 org.quartz.simpl.JDBCJobStoreTX。 实现持久化的第一步，是要创建 Quartz 持久化所需要的表格。在 Quartz 的发布包 docs/dbTables 中可以找到相应的表格创建脚本。Quartz 支持目前大部分流行的数据库。本文以 DB2 为例，所需要的脚本为 tables_db2.sql。首先需要对脚本做一点小的修改，即在开头指明 Schema： 1`SET CURRENT SCHEMA quartz;` 为了方便重复使用 , 创建表格前首先删除之前的表格： 1`drop table qrtz_job_listeners;` … 然后创建数据库 sched，执行 tables_db2.sql 创建持久化所需要的表格。 第二步，配置数据源。数据源与其它所有配置，例如 ThreadPool，均放在 quartz.properties 里： 清单 8. Quartz 配置文件1`# Configure ThreadPool ``org.quartz.threadPool.class = org.quartz.simpl.SimpleThreadPool ``org.quartz.threadPool.threadCount = 5 ``org.quartz.threadPool.threadPriority = 4 ` `# Configure Datasources ``org.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreTX ``org.quartz.jobStore.driverDelegateClass = org.quartz.impl.jdbcjobstore.StdJDBCDelegate ``org.quartz.jobStore.dataSource = db2DS ``org.quartz.jobStore.tablePrefix = QRTZ_ ` `org.quartz.dataSource.db2DS.driver = com.ibm.db2.jcc.DB2Driver ``org.quartz.dataSource.db2DS.URL = jdbc:db2://localhost:50001/sched ``org.quartz.dataSource.db2DS.user = quartz ``org.quartz.dataSource.db2DS.password = passw0rd ``org.quartz.dataSource.db2DS.maxConnections = 5` 使用时只需要将 quatz.properties 放在 classpath 下面，不用更改一行代码，再次运行之前的任务调度实例，trigger、job 等信息便会被记录在数据库中。 将清单 4 中的 makeWeeklyTrigger 改成 makeSecondlyTrigger，重新运行 main 函数，在 sched 数据库中查询表 qrtz_simple_triggers 中的数据。其查询语句为“db2 ‘ select repeat_interval, times_triggered from qrtz_simple_triggers ’”。结果 repeat_interval 为 1000，与程序中设置的 makeSecondlyTrigger 相吻合，times_triggered 值为 21。 停掉程序，将数据库中记录的任务调度数据重新导入程序运行： 清单 9. 从数据库中导入任务调度数据重新运行1`package com.ibm.scheduler; ``import org.quartz.Scheduler; ``import org.quartz.SchedulerException; ``import org.quartz.SchedulerFactory; ``import org.quartz.Trigger; ``import org.quartz.impl.StdSchedulerFactory; ` `public class QuartzReschedulerTest &#123; ``public static void main(String[] args) throws SchedulerException &#123; ``// 初始化一个 Schedule Factory ``SchedulerFactory schedulerFactory = new StdSchedulerFactory(); ``// 从 schedule factory 中获取 scheduler ``Scheduler scheduler = schedulerFactory.getScheduler(); ``// 从 schedule factory 中获取 trigger ``Trigger trigger = scheduler.getTrigger(&quot;myTrigger&quot;, &quot;myTriggerGroup&quot;); ``// 重新开启调度任务``scheduler.rescheduleJob(&quot;myTrigger&quot;, &quot;myTriggerGroup&quot;, trigger); ``scheduler.start(); ``&#125; ``&#125;` 清单 9 中，schedulerFactory.getScheduler() 将 quartz.properties 的内容加载到内存，然后根据数据源的属性初始化数据库的链接，并将数据库中存储的数据加载到内存。之后，便可以在内存中查询某一具体的 trigger，并将其重新启动。这时候重新查询 qrtz_simple_triggers 中的数据，发现 times_triggered 值比原来增长了。 JCronTab习惯使用 unix/linux 的开发人员应该对 crontab 都不陌生。Crontab 是一个非常方便的用于 unix/linux 系统的任务调度命令。JCronTab 则是一款完全按照 crontab 语法编写的 java 任务调度工具。 首先简单介绍一下 crontab 的语法，与上面介绍的 Quartz 非常相似，但更加简洁 , 集中了最常用的语法。主要由六个字段组成（括弧中标识了每个字段的取值范围）： 1`Minutes （0-59）``Hours （0-23） ``Day-of-Month （1-31）``Month （1-12/JAN-DEC） ``Day-of-Week （0-6/SUN-SAT）``Command` 与 Quartz 相比，省略了 Seconds 与 Year，多了一个 command 字段，即为将要被调度的命令。JCronTab 中也包含符号“*”与“/”, 其含义与 Quartz 相同。 举例如下： 每天 12 点到 15 点 , 每隔 1 小时执行一次 Date 命令： 1`0 12-15/1 * * * Date` 每月 2 号凌晨 1 点发一封信给 zhjingbj@cn.ibm.com： 1`0 1 2 * * mail -s “good” zhjingbj@cn.ibm.com` 每周一，周二，周三，周六的晚上 20:00 到 23:00，每半小时打印“normal”： 1`0/30 20-23 * * MON-WED,SAT echo “normal”` JCronTab 借鉴了 crontab 的语法，其区别在于 command 不再是 unix/linux 的命令，而是一个 Java 类。如果该类带参数，例如“com.ibm.scheduler.JCronTask2#run”，则定期执行 run 方法；如果该类不带参数，则默认执行 main 方法。此外，还可以传参数给 main 方法或者构造函数，例如“com.ibm.scheduler.JCronTask2#run Hello World“表示传两个参数 Hello 和 World 给构造函数。 JCronTab 与 Quartz 相比，其优点在于，第一，支持多种任务调度的持久化方法，包括普通文件、数据库以及 XML 文件进行持久化；第二，JCronTab 能够非常方便地与 Web 应用服务器相结合，任务调度可以随 Web 应用服务器的启动自动启动；第三，JCronTab 还内置了发邮件功能，可以将任务执行结果方便地发送给需要被通知的人。 JCronTab 与 Web 应用服务器的结合非常简单，只需要在 Web 应用程序的 web.xml 中添加如下行： 清单 10. 在 web.xml 中配置 JCronTab 的属性1`&lt;``servlet``&gt; `` ``&lt;``servlet-name``&gt;LoadOnStartupServlet&lt;/``servlet-name``&gt; `` ``&lt;``servlet-class``&gt;org.jcrontab.web.loadCrontabServlet&lt;/``servlet-class``&gt; `` ``&lt;``init-param``&gt; ``&lt;``param-name``&gt;PROPERTIES_FILE&lt;/``param-name``&gt; ``&lt;``param-value``&gt;D:/Scheduler/src/jcrontab.properties&lt;/``param-value``&gt; `` ``&lt;/``init-param``&gt; `` ``&lt;``load-on-startup``&gt;1&lt;/``load-on-startup``&gt; ``&lt;/``servlet``&gt; ``&lt;!-- Mapping of the StartUp Servlet --&gt;``&lt;``servlet-mapping``&gt; `` ``&lt;``servlet-name``&gt;LoadOnStartupServlet&lt;/``servlet-name``&gt; ``&lt;``url-pattern``&gt;/Startup&lt;/``url-pattern``&gt; ``&lt;/``servlet-mapping``&gt;` 在清单 10 中，需要注意两点：第一，必须指定 servlet-class 为 org.jcrontab.web.loadCrontabServlet，因为它是整个任务调度的入口；第二，必须指定一个参数为 PROPERTIES_FILE，才能被 loadCrontabServlet 识别。 接下来，需要撰写 D:/Scheduler/src/jcrontab.properties 的内容，其内容根据需求的不同而改变。 当采用普通文件持久化时，jcrontab.properties 的内容主要包括： 1`org.jcrontab.data.file = D:/Scheduler/src/crontab ``org.jcrontab.data.datasource = org.jcrontab.data.FileSource` 其中数据来源 org.jcrontab.data.datasource 被描述为普通文件，即 org.jcrontab.data.FileSource。具体的文件即 org.jcrontab.data.file 指明为 D:/Scheduler/src/crontab。 Crontab 描述了任务的调度安排： 1`*/2 * * * * com.ibm.scheduler.JCronTask1 ``* * * * * com.ibm.scheduler.JCronTask2#run Hello World` 其中包含了两条任务的调度，分别是每两分钟执行一次 JCronTask1 的 main 方法，每一分钟执行一次 JCronTask2 的 run 方法。 清单 11. JcronTask1 与 JCronTask2 的实现1`package com.ibm.scheduler;` `import java.util.Date;` `public class JCronTask1 &#123;` ` ``private static int count = 0;` ` ``public static void main(String[] args) &#123;`` ``System.out.println(&quot;--------------Task1-----------------&quot;);`` ``System.out.println(&quot;Current Time = &quot; + new Date() + &quot;, Count = &quot;`` ``+ count++);`` ``&#125;``&#125;` `package com.ibm.scheduler;` `import java.util.Date;` `public class JCronTask2 implements Runnable &#123;` ` ``private static int count = 0;` ` ``private static String[] args;` ` ``public JCronTask2(String[] args) &#123;`` ``System.out.println(&quot;--------------Task2-----------------&quot;);`` ``System.out.println(&quot;Current Time = &quot; + new Date() + &quot;, Count = &quot;`` ``+ count++);`` ``JCronTask2.args = args;`` ``&#125;` ` ``@Override`` ``public void run() &#123;`` ``System.out.println(&quot;enter into run method&quot;);`` ``if (args != null &amp;&amp; args.length &gt; 0) &#123;`` ``for (int i = 0; i &lt; args.length; i++) &#123;`` ``System.out.print(&quot;This is arg &quot; + i + &quot; &quot; + args[i] + &quot;\\n&quot;);`` ``&#125;`` ``&#125;`` ``&#125;``&#125;` 到此为止，基于普通文件持久化的 JCronTab 的实例就全部配置好了。启动 Web 应用服务器，便可以看到任务调度的输出结果： 1`--------------Task2----------------- ``Current Time = Tue Feb 15 09:22:00 CST 2011, Count = 0 ``enter into run method ``This is arg 0 Hello ``This is arg 1 World ``--------------Task1----------------- ``Current Time = Tue Feb 15 09:22:00 CST 2011, Count = 0 ``--------------Task2----------------- ``Current Time = Tue Feb 15 09:23:00 CST 2011, Count = 1 ``enter into run method ``This is arg 0 Hello ``This is arg 1 World ``--------------Task2----------------- ``Current Time = Tue Feb 15 09:24:00 CST 2011, Count = 2 ``enter into run method ``This is arg 0 Hello ``This is arg 1 World ``--------------Task1----------------- ``Current Time = Tue Feb 15 09:24:00 CST 2011, Count = 1` 通过修改 jcrontab.properties 中 datasource，可以选择采用数据库或 xml 文件持久化，感兴趣的读者可以参考 进阶学习 JCronTab。 此外，JCronTab 还内置了发邮件功能，可以将任务执行结果方便地发送给需要被通知的人。其配置非常简单，只需要在 jcontab.properties 中添加几行配置即可： 1`org.jcrontab.sendMail.to= Ther email you want to send to ``org.jcrontab.sendMail.from=The email you want to send from ``org.jcrontab.sendMail.smtp.host=smtp server ``org.jcrontab.sendMail.smtp.user=smtp username ``org.jcrontab.sendMail.smtp.password=smtp password` 结束语本文介绍了四种常用的对任务进行调度的 Java 实现方法，即 Timer，ScheduledExecutor, Quartz 以及 JCronTab。文本对每种方法都进行了实例解释，并对其优缺点进行比较。对于简单的基于起始时间点与时间间隔的任务调度，使用 Timer 就足够了；如果需要同时调度多个任务，基于线程池的 ScheduledTimer 是更为合适的选择；当任务调度的策略复杂到难以凭借起始时间点与时间间隔来描述时，Quartz 与 JCronTab 则体现出它们的优势。熟悉 Unix/Linux 的开发人员更倾向于 JCronTab，且 JCronTab 更适合与 Web 应用服务器相结合。Quartz 的 Trigger 与 Job 松耦合设计使其更适用于 Job 与 Trigger 的多对多应用场景。"}]